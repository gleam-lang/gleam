// vi: ft=rust

use std::str::FromStr;

use crate::ast::{UntypedExpr, Expr, Scope, Arg, UntypedModule, Module, UntypedStatement, Statement, Type, Pattern};
use crate::parser::*;

grammar;

pub Module: UntypedModule = {
    Statement* => Module {
        name: "".to_string(),
        statements: <>,
    }
}

Statement: UntypedStatement = {
    StatementFun => <>,
    StatementTest => <>,
    // StatementEnum => <>,
    StatementExternalFun => <>,
    StatementExternalType => <>,
    StatementImport => <>,
}

StatementExternalFun: UntypedStatement = {
    <s:@L> <p:"pub"?> "external" "fn" <n:VarName> "(" <a:Comma<Type>> ")" "->" <r:Type> "=" <m:RawAtom> <f:RawAtom> <e:@L> => Statement::ExternalFun {
        meta: meta(s, e),
        public: p.is_some(),
        name: n,
        args: a,
        module: m,
        fun: f,
        retrn: r,
    }
}

StatementFun: UntypedStatement = {
    <s:@L> <p:"pub"?> "fn" <n:VarName> "(" <a:Comma<FnArg>> ")" "{" <b:Expr> "}" <e:@L> => Statement::Fun {
        meta: meta(s, e),
        public: p.is_some(),
        name: n,
        args: a,
        body: b,
    }
}

StatementTest: UntypedStatement = {
    <s:@L> "test" <n:VarName> "{" <b:Expr> "}" <e:@L> => Statement::Test {
        meta: meta(s, e),
        name: n,
        body: b,
    }
}

StatementImport: UntypedStatement = {
    <s:@L> "import" <n:VarName> <e:@L> => Statement::Import {
        meta: meta(s, e),
        module: n,
    }
}

StatementExternalType: UntypedStatement = {
    <s:@L> <p:"pub"?> "external" "type" <n:TypeName> <e:@L> => Statement::ExternalType {
        meta: meta(s, e),
        public: p.is_some(),
        name: n.0,
        args: n.1,
    }
}

pub Expr: UntypedExpr = {
    Let => <>,
    Seq => <>,
    SingleExpr => <>,
}

SingleExpr: UntypedExpr = {
    Nil => <>,
    Int => <>,
    Var => <>,
    Fun => <>,
    Cons => <>,
    Call => <>,
    Atom => <>,
    Float => <>,
    Tuple => <>,
    String => <>,
    // BinOp => <>,
    // Case => <>,
    RecordNil => <>,
    Constructor => <>,
    RecordCons => <>,
    RecordSelect => <>,
    ModuleSelect => <>,
}

Let: UntypedExpr = {
    <s:@L> <p:Pattern> "=" <v:SingleExpr> <e:@L> <t:Expr> => Expr::Let {
        meta: meta(s, e),
        typ: (),
        value: Box::new(v),
        pattern: p,
        then: Box::new(t),
    }
}

RecordSelect: UntypedExpr = {
    <s:@L> <r:SingleExpr> "." <l:VarName> <e:@L> => Expr::RecordSelect {
        meta: meta(s, e),
        typ: (),
        label: l,
        record: Box::new(r),
    },
}

// TODO: multiple fields
RecordCons: UntypedExpr = {
    <s:@L> "{" <r:SingleExpr> "|" <l:VarName> "=" <v:SingleExpr> "}" <e:@L> => Expr::RecordCons {
        meta: meta(s, e),
        typ: (),
        label: l,
        value: Box::new(v),
        tail: Box::new(r),
    },
}

ModuleSelect: UntypedExpr = {
    <s:@L> <m:SingleExpr> ":" <l:VarName> <e:@L> => Expr::ModuleSelect {
        meta: meta(s, e),
        typ: (),
        label: l,
        module: Box::new(m),
    },
}

Seq: UntypedExpr = {
    <s:@L> <a:SingleExpr> <b:Expr> <e:@L> => Expr::Seq {
        meta: meta(s, e),
        typ: (),
        first: Box::new(a),
        then: Box::new(b),
    }
}

Fun: UntypedExpr = {
    <s:@L> "fn(" <a:Comma<FnArg>> ")" "{" <b:Expr> "}" <e:@L> => Expr::Fun {
        meta: meta(s, e),
        typ: (),
        args: a,
        body: Box::new(b),
    }
}

FnArg: Arg = {
    VarName => Arg {
        name: <>,
    },
}

Constructor: UntypedExpr = {
    <s:@L> <n:ConstructorName> <e:@L> => Expr::Constructor {
        meta: meta(s, e),
        typ: (),
        name: n,
    },
}

Call: UntypedExpr = {
    <s:@L> <fun:SingleExpr> "(" <args:Comma<Expr>> ")" <e:@L> => Expr::Call {
        meta: meta(s, e),
        typ: (),
        fun: Box::new(fun),
        args: args,
    }
}

Tuple: UntypedExpr = {
    <s:@L> "{" <elems:Comma<Expr>> "}" <e:@L> => Expr::Tuple {
        meta: meta(s, e),
        typ: (),
        elems: elems,
    }
}

Cons: UntypedExpr = {
    <s:@L> "[" <head:Expr> "|" <tail:Expr> "]" <e:@L> => Expr::Cons {
        meta: meta(s, e),
        typ: (),
        head: Box::new(head),
        tail: Box::new(tail),
    }
}

Var: UntypedExpr = {
    <s:@L> <v:VarName> <e:@L> => Expr::Var {
        meta: meta(s, e),
        typ: (),
        name: v,
        scope: Scope::Local,
    }
}

Nil: UntypedExpr = {
    <s:@L> "[]" <e:@L> => Expr::Nil {
        meta: meta(s, e),
        typ: (),
    }
}

RecordNil: UntypedExpr = {
    <s:@L> "{}" <e:@L> => Expr::RecordNil {
        meta: meta(s, e),
        typ: (),
    }
}

// TODO: Unescape?
Atom: UntypedExpr = {
    <s:@L> <x:RawAtom> <e:@L> => Expr::Atom {
        meta: meta(s, e),
        typ: (),
        value: x,
    }
}

// TODO: Unescape?
String: UntypedExpr = {
    <s:@L> <x:RawString> <e:@L> => Expr::String {
        meta: meta(s, e),
        typ: (),
        value: x,
    }
}

Int: UntypedExpr = {
    <s:@L> <i:r"-?[0-9]+"> <e:@L> => Expr::Int {
        meta: meta(s, e),
        typ: (),
        value: i64::from_str(i).unwrap(),
    }
}

Float: UntypedExpr = {
    <s:@L> <f:r"-?[0-9]+\.+[0-9]*"> <e:@L> => Expr::Float {
        meta: meta(s, e),
        typ: (),
        value: f64::from_str(f).unwrap(),
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Pattern: Pattern = {
    PatternVar => <>,
    PatternInt => <>,
    // PatternList => <>,
    PatternAtom => <>,
    // PatternEnum => <>,
    PatternFloat => <>,
    // PatternTuple => <>,
    PatternString => <>,
    // PatternRecord => <>,
}

PatternFloat: Pattern = {
    <s:@L> <f:r"-?[0-9]+\.+[0-9]*"> <e:@L> => Pattern::Float {
        meta: meta(s, e),
        value: f64::from_str(f).unwrap(),
    }
}

PatternAtom: Pattern = {
    <s:@L> <a:RawAtom> <e:@L> => Pattern::Atom {
        meta: meta(s, e),
        value: a,
    }
}

PatternString: Pattern = {
    <s:@L> <a:RawString> <e:@L> => Pattern::String {
        meta: meta(s, e),
        value: a,
    }
}

PatternInt: Pattern = {
    <s:@L> <i:r"-?[0-9]+"> <e:@L> => Pattern::Int {
        meta: meta(s, e),
        value: i64::from_str(i).unwrap(),
    }
}

PatternVar: Pattern = {
    <s:@L> <v:VarName> <e:@L> => Pattern::Var {
        meta: meta(s, e),
        name: v,
    }
}

Type: Type = {
    TypeConstructor => <>,
    TypeVar => <>,
}

TypeConstructor: Type = {
    <s:@L> <n:r"[A-Z][A-Za-z]*"> <e:@L> => Type::Constructor {
        meta: meta(s, e),
        args: vec![],
        name: n.to_string(),
    },
    <s:@L> <n:r"[A-Z][A-Za-z]*"> "(" <a:Comma<Type>> ")" <e:@L> => Type::Constructor {
        meta: meta(s, e),
        args: a,
        name: n.to_string(),
    },
}

TypeVar: Type = {
    <s:@L> <n:VarName> <e:@L> => Type::Var {
        meta: meta(s, e),
        name: n,
    }
}

TypeName: (String, Vec<String>) = {
    <v:r"[A-Z][A-Za-z]*"> => (v.to_string(), vec![]),
    <v:r"[A-Z][A-Za-z]*"> "(" <a:Comma<VarName>> ")" => (v.to_string(), a),
}

VarName: String = {
    <v:r"[a-z][A-za-z_]*"> => v.to_string()
}

ConstructorName: String = {
    <v:r"[A-Z][A-Za-z]*"> => v.to_string()
}

RawString: String = {
    <x:r#""(([^\\"]|\\.)*)""#> => x[1..(x.len() - 1)].to_string(),
}

RawAtom: String = {
    <x:r"'(([^\\']|\\.)*)'"> => x[1..(x.len() - 1)].to_string(),
}
