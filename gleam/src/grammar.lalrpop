// vi: ft=rust

use std::str::FromStr;

use crate::ast::{
    UntypedExpr, Expr, Arg, UntypedModule, Module, UntypedStatement, Statement, Type, Pattern,
    BinOp, Clause, UntypedClause, EnumConstructor
};
use crate::parser::*;

grammar;

pub Module: UntypedModule = {
    Statement* => Module {
        typ: (),
        name: vec![],
        statements: <>,
    }
}

Statement: UntypedStatement = {
    StatementFn => <>,
    StatementEnum => <>,
    StatementExternalFn => <>,
    StatementExternalType => <>,
    StatementImport => <>,
}

StatementEnum: UntypedStatement = {
    <s:@L> <p:"pub"?> "enum" <t:TypeName> "=" <cs:EnumConstructor+> <e:@L> => Statement::Enum {
        meta: meta(s, e),
        public: p.is_some(),
        name: t.0,
        args: t.1,
        constructors: cs,
    }
}

EnumConstructor: EnumConstructor = {
    "|" <s:@L> <t:UpName> <args:EnumConstructorArgs?> <e:@L> => EnumConstructor {
        meta: meta(s, e),
        name: t,
        args: args.unwrap_or_else(|| vec![]),
    },
}

EnumConstructorArgs: Vec<Type> = {
    "(" <ts:Comma<Type>> ")" => ts
}

StatementExternalFn: UntypedStatement = {
    <s:@L> <p:"pub"?> "external" "fn" <n:VarName> "(" <a:Comma<Type>> ")" "->" <r:Type> "=" <m:RawString> <f:RawString> <e:@L> => Statement::ExternalFn {
        meta: meta(s, e),
        public: p.is_some(),
        name: n,
        args: a,
        module: m,
        fun: f,
        retrn: r,
    }
}

StatementFn: UntypedStatement = {
    <s:@L> <p:"pub"?> "fn" <n:VarName> "(" <a:Comma<FnArg>> ")" "{" <b:Expr+> "}" <e:@L> => Statement::Fn {
        meta: meta(s, e),
        public: p.is_some(),
        name: n,
        args: a,
        body: seq(b),
    }
}

StatementImport: UntypedStatement = {
    <s:@L> "import" <n:VarName> <e:@L> => Statement::Import {
        meta: meta(s, e),
        module: vec![n],
    }
}

StatementExternalType: UntypedStatement = {
    <s:@L> <p:"pub"?> "external" "type" <n:TypeName> <e:@L> => Statement::ExternalType {
        meta: meta(s, e),
        public: p.is_some(),
        name: n.0,
        args: n.1,
    }
}

pub Expr: UntypedExpr = {
    Let => <>,
    OpOrSimpleExpr => <>,
}

OpOrSimpleExpr: UntypedExpr = {
    <o:Op<OrOp, OpOrSimpleExpr, Op2>> => <>,
    Op2 => <>,
}

OrOp: BinOp = {
    "||" => BinOp::Or,
}

Op2: UntypedExpr = {
    <o:Op<AndOp, Op2, Op3>> => <>,
    Op3 => <>,
}

AndOp: BinOp = {
    "&&" => BinOp::And,
}

Op3: UntypedExpr = {
    <o:Op<EqOp, Op3, Op4>> => <>,
    Op4 => <>,
}

EqOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::NotEq,
}

Op4: UntypedExpr = {
    <o:Op<CompareOp, Op4, Op5>> => <>,
    Op5 => <>,
}

CompareOp: BinOp = {
    "<" => BinOp::Lt,
    "<=" => BinOp::LtEq,
    ">" => BinOp::Gt,
    ">=" => BinOp::GtEq,
}

Op5: UntypedExpr = {
    <o:Op<PipeOp, Op5, Op6>> => <>,
    Op6 => <>,
}

PipeOp: BinOp = {
    "|>" => BinOp::Pipe,
}

Op6: UntypedExpr = {
    <o:Op<AddOp, Op6, Op7>> => <>,
    Op7 => <>,
}

AddOp: BinOp = {
    "+" => BinOp::AddInt,
    "+." => BinOp::AddFloat,
    "-" => BinOp::SubInt,
    "-." => BinOp::SubFloat,
}

Op7: UntypedExpr = {
    <o:Op<MultOp, Op7, SimpleExpr>> => <>,
    SimpleExpr => <>,
}

MultOp: BinOp = {
    "%" => BinOp::ModuloInt,
    "*" => BinOp::MultInt,
    "*." => BinOp::MultFloat,
    "/" => BinOp::DivInt,
    "/." => BinOp::DivFloat,
}

SimpleExpr: UntypedExpr = {
    Fn => <>,
    Nil => <>,
    Int => <>,
    Var => <>,
    Case => <>,
    Cons => <>,
    List => <>,
    Call => <>,
    Float => <>,
    Tuple => <>,
    String => <>,
    Map => <>,
    MapNil => <>,
    MapCons => <>,
    // Constructor => <>,
    MapSelect => <>,
    ModuleSelect => <>,
    "begin" <e:Expr> "end" => e,
}

Case: UntypedExpr = {
    <s:@L> "case" <subject:OpOrSimpleExpr> "{" <clauses:Clause+> "}" <e:@L> => Expr::Case {
        meta: meta(s, e),
        typ: (),
        subject: Box::new(subject),
        clauses,
    }
}

Clause: UntypedClause = {
    <s:@L> "|" <pattern:Pattern> "->" <then:Expr+> <e:@L> => Clause {
        meta: meta(s, e),
        pattern,
        then: seq(then),
    }
}

Let: UntypedExpr = {
    <s:@L> "let" <p:Pattern> "=" <v:OpOrSimpleExpr> <e:@L> <t:Expr> => Expr::Let {
        meta: meta(s, e),
        typ: (),
        value: Box::new(v),
        pattern: p,
        then: Box::new(t),
    }
}

MapSelect: UntypedExpr = {
    <s:@L> <r:SimpleExpr> "." <l:VarName> <e:@L> => Expr::MapSelect {
        meta: meta(s, e),
        typ: (),
        label: l,
        map: Box::new(r),
    },
}

MapNil: UntypedExpr = {
    <s:@L> "{}" <e:@L> => Expr::MapNil {
        meta: meta(s, e),
        typ: (),
    }
}

Map: UntypedExpr = {
    <s:@L> "{" <fields:MapFields> "}" <e:@L> => {
        fields.into_iter().fold(
            Expr::MapNil {
                meta: meta(e - 1, e),
                typ: (),
            },
            |a, e| Expr::MapCons {
                meta: e.1.meta().clone(),
                typ: (),
                label: e.0,
                value: Box::new(e.1),
                tail: Box::new(a),
            }
        )
    }
}

MapCons: UntypedExpr = {
    <s:@L> "{" <r:SimpleExpr> "|" <fields:MapFields> "}" <e:@L> => {
        fields.into_iter().fold(r, |a, f| Expr::MapCons {
            meta: meta(s, e),
            typ: (),
            label: f.0,
            value: Box::new(f.1),
            tail: Box::new(a),
        })
    }
}

ModuleSelect: UntypedExpr = {
    <s:@L> <m:SimpleExpr> ":" <l:VarName> <e:@L> => Expr::ModuleSelect {
        meta: meta(s, e),
        typ: (),
        label: l,
        module: Box::new(m),
    },

    <s:@L> <m:SimpleExpr> ":" <l:UpName> <e:@L> => Expr::ModuleSelect {
        meta: meta(s, e),
        typ: (),
        label: l,
        module: Box::new(m),
    },
}

Fn: UntypedExpr = {
    <s:@L> "fn(" <a:Comma<FnArg>> ")" "{" <b:Expr+> "}" <e:@L> => Expr::Fn {
        meta: meta(s, e),
        is_capture: false,
        typ: (),
        args: a,
        body: Box::new(seq(b)),
    }
}

FnArg: Arg = {
    VarName => Arg {
        name: Some(<>),
    },

    DiscardName => Arg {
        name: None,
    },
}

Call: UntypedExpr = {
    <s:@L> <fun:SimpleExpr> "(" <args:Comma<CallArg>> ")" <e:@L> =>? {
        let hole_arg_name = "capture@1";
        let mut num_holes = 0;
        let args = args.into_iter().map(|a| match a {
            Ok(arg) => arg,
            Err(meta) => {
                num_holes += 1;
                Expr::Var {
                    meta,
                    typ: (),
                    scope: (),
                    name: hole_arg_name.to_string(),
                }
            }
        }).collect();
        let call = Expr::Call {
            meta: meta(s, e),
            typ: (),
            fun: Box::new(fun),
            args: args,
        };
        match num_holes {
            // A normal call
            0 => Ok(call),

            // An anon function using the capture syntax run(_, 1, 2)
            1 => Ok(Expr::Fn {
                meta: call.meta().clone(),
                typ: (),
                is_capture: true,
                args: vec![Arg { name: Some(hole_arg_name.to_string()) }],
                body: Box::new(call),
            }),

            _ => Err(lalrpop_util::ParseError::User {
                error: "too many holes in capture" // TODO: Real error
            })
        }
    }
}

CallArg: Result<UntypedExpr, crate::ast::Meta> = {
    <arg:OpOrSimpleExpr> => Ok(arg),
    <s:@L> DiscardName <e:@L> => Err(meta(s, e)),
}

Tuple: UntypedExpr = {
    <s:@L> "{" <elems:Comma<OpOrSimpleExpr>> "}" <e:@L> => Expr::Tuple {
        meta: meta(s, e),
        typ: (),
        elems: elems,
    }
}

Cons: UntypedExpr = {
    <s:@L> "[" <head:OpOrSimpleExpr> "|" <tail:OpOrSimpleExpr> "]" <e:@L> => Expr::Cons {
        meta: meta(s, e),
        typ: (),
        head: Box::new(head),
        tail: Box::new(tail),
    }
}

List: UntypedExpr = {
    <s:@L> "[" <elems:Comma<OpOrSimpleExpr>> "]" <e:@L> => {
        elems.into_iter().rev().fold(
            Expr::Nil {
                meta: meta(e - 1, e),
                typ: (),
            },
            |a, e| Expr::Cons {
                meta: e.meta().clone(),
                typ: (),
                head: Box::new(e),
                tail: Box::new(a),
            }
        )
    }
}

Var: UntypedExpr = {
    <s:@L> <v:VarName> <e:@L> => Expr::Var {
        meta: meta(s, e),
        typ: (),
        scope: (),
        name: v,
    },

    <s:@L> <v:UpName> <e:@L> => Expr::Var {
        meta: meta(s, e),
        typ: (),
        scope: (),
        name: v,
    }
}

Nil: UntypedExpr = {
    <s:@L> "[]" <e:@L> => Expr::Nil {
        meta: meta(s, e),
        typ: (),
    }
}

String: UntypedExpr = {
    <s:@L> <x:RawString> <e:@L> => Expr::String {
        meta: meta(s, e),
        typ: (),
        value: x,
    }
}

Int: UntypedExpr = {
    <s:@L> <i:r"-?[0-9]+"> <e:@L> => Expr::Int {
        meta: meta(s, e),
        typ: (),
        value: i64::from_str(i).unwrap(),
    }
}

Float: UntypedExpr = {
    <s:@L> <f:r"-?[0-9]+\.+[0-9]*"> <e:@L> => Expr::Float {
        meta: meta(s, e),
        typ: (),
        value: f64::from_str(f).unwrap(),
    }
}

MapField: (String, UntypedExpr) = {
    <l:VarName> "=" <v:OpOrSimpleExpr> => {
        (l, v)
    }
}

MapFields: Vec<(String, UntypedExpr)> = {
    MapField => vec![<>],

    <x:MapField> "," => vec![x],

    <x:MapField> "," <xs:MapFields> => {
        let mut xs = xs;
        xs.push(x);
        xs
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

AtLeastOneComma<T>: Vec<T> = {
    <v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Op<Operator, Current, Next>: UntypedExpr = {
    <s:@L> <l:(<Current>)> <o:(<Operator>)> <r:Next> <e:@L> => Expr::BinOp {
        meta: meta(s, e),
        typ: (),
        name: o,
        left: Box::new(l),
        right: Box::new(r),
    },
}

Pattern: Pattern = {
    PatternVar => <>,
    PatternInt => <>,
    PatternNil => <>,
    PatternCons => <>,
    PatternList => <>,
    PatternFloat => <>,
    PatternTuple => <>,
    PatternString => <>,
    PatternDiscard => <>,
    // PatternMap => <>,
    PatternConstructor => <>,
}

PatternConstructor: Pattern = {
    <s:@L> <name:UpName> <args:PatternConstructorArgs?> <e:@L> => Pattern::Constructor {
        meta: meta(s, e),
        module: None,
        args: args.unwrap_or_else(|| vec![]),
        name,
    },

    <s:@L> <module:VarName> ":" <name:UpName> <args:PatternConstructorArgs?> <e:@L> => Pattern::Constructor {
        meta: meta(s, e),
        module: Some(module),
        args: args.unwrap_or_else(|| vec![]),
        name,
    },
}

PatternConstructorArgs: Vec<Pattern> = {
    "(" <ts:Comma<Pattern>> ")" => ts
}

PatternTuple: Pattern = {
    <s:@L> "{" <elems:Comma<Pattern>> "}" <e:@L> => Pattern::Tuple {
        meta: meta(s, e),
        elems,
    }
}

PatternFloat: Pattern = {
    <s:@L> <f:r"-?[0-9]+\.+[0-9]*"> <e:@L> => Pattern::Float {
        meta: meta(s, e),
        value: f64::from_str(f).unwrap(),
    }
}

PatternString: Pattern = {
    <s:@L> <a:RawString> <e:@L> => Pattern::String {
        meta: meta(s, e),
        value: a,
    }
}

PatternInt: Pattern = {
    <s:@L> <i:r"-?[0-9]+"> <e:@L> => Pattern::Int {
        meta: meta(s, e),
        value: i64::from_str(i).unwrap(),
    }
}

PatternVar: Pattern = {
    <s:@L> <v:VarName> <e:@L> => Pattern::Var {
        meta: meta(s, e),
        name: v,
    }
}

PatternDiscard: Pattern = {
    <s:@L> <_d:DiscardName> <e:@L> => Pattern::Discard {
        meta: meta(s, e),
    }
}

PatternNil: Pattern = {
    <s:@L> "[]" <e:@L> => Pattern::Nil {
        meta: meta(s, e),
    }
}

PatternList: Pattern = {
    <s:@L> "[" <elems:Comma<Pattern>> "]" <e:@L> => {
        elems.into_iter().rev().fold(
            Pattern::Nil {
                meta: meta(e - 1, e),
            },
            |a, e| Pattern::Cons {
                meta: e.meta().clone(),
                head: Box::new(e),
                tail: Box::new(a),
            }
        )
    }
}

PatternCons: Pattern = {
    <s:@L> "[" <head:Pattern> "|" <tail:Pattern> "]" <e:@L> => Pattern::Cons {
        meta: meta(s, e),
        head: Box::new(head),
        tail: Box::new(tail),
    }
}

Type: Type = {
    TypeConstructor => <>,
    TypeMap => <>,
    TypeModule => <>,
    TypeTuple => <>,
    TypeVar => <>,
    TypeFn => <>,
}

TypeModule: Type = {
    <s:@L> "module" "{}" <e:@L> => Type::Module {
        meta: meta(s, e),
        fields: vec![],
        tail: None,
    },

    <s:@L> "module" "{" <tail:TypeMapTail?> <fields:TypeModuleField*> "}" <e:@L> => Type::Module {
        meta: meta(s, e),
        fields,
        tail,
    },
}

TypeModuleField: (String, Type) = {
    "const" <l:VarName> ":" <t:Type> => (l, t),

    <s:@L> "fn" <l:VarName> "(" <args:Comma<Type>> ")" "->" <retrn:Type> <e:@L> => {
        let f = Type::Fn {
            meta: meta(s, e),
            retrn: Box::new(retrn),
            args,
        };
        (l, f)
    }
}

TypeMap: Type = {
    <s:@L> "{}" <e:@L> => Type::Map {
        meta: meta(s, e),
        fields: vec![],
        tail: None,
    },

    <s:@L> "{" <tail:TypeMapTail?> <fields:Comma<TypeMapField>> "}" <e:@L> => Type::Map {
        meta: meta(s, e),
        fields,
        tail,
    },
}

TypeMapTail: Box<Type> = {
    <s:@L> <n:VarName> <e:@L> "|" => Box::new(Type::Var {
        meta: meta(s, e),
        name: n,
    })
}

TypeMapField: (String, Type) = {
    <l:VarName> "=" <t:Type> => (l, t)
}

TypeConstructor: Type = {
    <s:@L> <m:VarName> ":" <n:r"[A-Z][A-Za-z]*"> <e:@L> => Type::Constructor {
        meta: meta(s, e),
        module: Some(m),
        args: vec![],
        name: n.to_string(),
    },

    <s:@L> <m:VarName> ":" <n:r"[A-Z][A-Za-z]*"> "(" <a:Comma<Type>> ")" <e:@L> => Type::Constructor {
        meta: meta(s, e),
        module: Some(m),
        args: a,
        name: n.to_string(),
    },

    <s:@L> <n:r"[A-Z][A-Za-z]*"> <e:@L> => Type::Constructor {
        meta: meta(s, e),
        module: None,
        args: vec![],
        name: n.to_string(),
    },

    <s:@L> <n:r"[A-Z][A-Za-z]*"> "(" <a:Comma<Type>> ")" <e:@L> => Type::Constructor {
        meta: meta(s, e),
        module: None,
        args: a,
        name: n.to_string(),
    },
}

TypeTuple: Type = {
    <s:@L> "{" <elems:AtLeastOneComma<Type>> "}" <e:@L> => Type::Tuple {
        meta: meta(s, e),
        elems: elems,
    }
}


TypeVar: Type = {
    <s:@L> <n:VarName> <e:@L> => Type::Var {
        meta: meta(s, e),
        name: n,
    }
}

TypeFn: Type = {
    <s:@L> "fn(" <args:Comma<Type>> ")" "->" <retrn:Type> <e:@L> => Type::Fn {
        meta: meta(s, e),
        retrn: Box::new(retrn),
        args,
    }
}

TypeName: (String, Vec<String>) = {
    <v:UpName> => (v, vec![]),
    <v:UpName> "(" <a:Comma<VarName>> ")" => (v, a),
}

UpName: String = {
    <v:r"[A-Z][A-Za-z]*"> => v.to_string()
}

DiscardName: () = {
    <v:r"_[A-Za-z_]*"> => ()
}

VarName: String = {
    <v:r"[a-z][0-9a-z_]*"> => v.to_string()
}

ConstructorName: String = {
    <v:r"[A-Z][A-Za-z]*"> => v.to_string()
}

RawString: String = {
    <x:r#""(([^\\"]|\\.)*)""#> => x[1..(x.len() - 1)].to_string(),
}
