<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Gleam Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Hello, Gleam!</a></li><li><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li><a href="getting-started/installing-gleam.html"><strong aria-hidden="true">2.1.</strong> Installing Gleam</a></li><li><a href="getting-started/installing-erlang.html"><strong aria-hidden="true">2.2.</strong> Installing Erlang</a></li><li><a href="getting-started/editor-support.html"><strong aria-hidden="true">2.3.</strong> Editor support</a></li><li><a href="getting-started/creating-a-project.html"><strong aria-hidden="true">2.4.</strong> Creating a project</a></li><li><a href="getting-started/example-projects.html"><strong aria-hidden="true">2.5.</strong> Example projects</a></li></ol></li><li><a href="tour/index.html"><strong aria-hidden="true">3.</strong> Language tour</a></li><li><ol class="section"><li><a href="tour/comments.html"><strong aria-hidden="true">3.1.</strong> Comments</a></li><li><a href="tour/string.html"><strong aria-hidden="true">3.2.</strong> String</a></li><li><a href="tour/bool.html"><strong aria-hidden="true">3.3.</strong> Bool</a></li><li><a href="tour/int-and-float.html"><strong aria-hidden="true">3.4.</strong> Int &amp; Float</a></li><li><a href="tour/let.html"><strong aria-hidden="true">3.5.</strong> Let bindings</a></li><li><a href="tour/tuple.html"><strong aria-hidden="true">3.6.</strong> Tuple</a></li><li><a href="tour/list.html"><strong aria-hidden="true">3.7.</strong> List</a></li><li><a href="tour/case.html"><strong aria-hidden="true">3.8.</strong> Case</a></li><li><a href="tour/function.html"><strong aria-hidden="true">3.9.</strong> Function</a></li><li><a href="tour/module.html"><strong aria-hidden="true">3.10.</strong> Module</a></li><li><a href="tour/map.html"><strong aria-hidden="true">3.11.</strong> Map</a></li><li><a href="tour/enum.html"><strong aria-hidden="true">3.12.</strong> Enum</a></li><li><a href="tour/external-function.html"><strong aria-hidden="true">3.13.</strong> External function</a></li><li><a href="tour/external-type.html"><strong aria-hidden="true">3.14.</strong> External type</a></li></ol></li><li><a href="faqs.html"><strong aria-hidden="true">4.</strong> FAQs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Gleam Book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gleam" id="gleam">Gleam</a></h1>
<p>Gleam is a statically typed functional programming language for building
scalable concurrent systems.</p>
<p>It compiles to <a href="http://www.erlang.org/">Erlang</a> and has straightforward
interop with other BEAM languages such as Erlang, Elixir and LFE.</p>
<p>It looks like this:</p>
<pre><code class="language-rust noplaypen">pub enum Tree(value) =
  | Leaf(value)
  | Node(Tree(value), Tree(value))

pub fn any(tree: Tree(a), check: fn(a) -&gt; Bool) -&gt; Bool {
  case tree {
  | Leaf(i) -&gt; check(i)
  | Node(left, right) -&gt; any(left, check) || any(right, check)
  }
}

pub fn has_even_leaf(tree: Tree(Int)) -&gt; Bool {
  any(tree, fn(i) {
    i % 2 == 0
  })
}
</code></pre>
<p>The source code can be found at
<a href="https://github.com/lpil/gleam">https://github.com/lpil/gleam</a>.</p>
<p>For Gleam chat we have the IRC channel <code>#gleam-lang</code> on Freenode.</p>
<h2><a class="header" href="#principles" id="principles">Principles</a></h2>
<h3><a class="header" href="#be-safe" id="be-safe">Be safe</a></h3>
<p>An expressive type system inspired by the ML family of languages helps us find
and prevent bugs at compile time, long before it reaches your users.</p>
<p>For the problems the type system can't solve (such as your server being hit by
a bolt of lightning) the Erlang/OTP runtime provides well tested mechanisms
for gracefully handling failure.</p>
<h3><a class="header" href="#be-friendly" id="be-friendly">Be friendly</a></h3>
<p>Hunting down bugs can be stressful so feedback from the compiler should be
as clear and helpful as possible. We want to spend more time working on our
application and less time looking for typos or deciphering cryptic error
messages.</p>
<p>As a community we want to be friendly too. People of all backgrounds, genders,
and experience levels are welcome and must receive equal respect.</p>
<h3><a class="header" href="#be-performant" id="be-performant">Be performant</a></h3>
<p>The Erlang/OTP runtime is known for its speed and ability to scale, enabling
organisations such as WhatsApp and Ericsson to reliably handle massive amounts
of traffic at low latency. Gleam should take full advantage of this runtime
and be as fast as other BEAM languages such as Erlang and Elixir.</p>
<h3><a class="header" href="#be-a-good-citizen" id="be-a-good-citizen">Be a good citizen</a></h3>
<p>Gleam makes it easy to use code written in other BEAM languages such as
Erlang, Elixir and LFE, so there's a rich ecosystem of tools and library for
Gleam users to make use of.</p>
<p>Users of other BEAM languages should in return be able to take advantage of
Gleam, either by transparently making use of libraries written in Gleam, or by
adding Gleam modules to their existing project with minimal fuss.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>In this chapter we get the Gleam language set up on your computer and learn
how to create an navigate a Gleam project.</p>
<p>Good luck, have fun!</p>
<h1><a class="header" href="#installing-gleam" id="installing-gleam">Installing Gleam</a></h1>
<h2><a class="header" href="#precompiled-for-linux-or-macos" id="precompiled-for-linux-or-macos">Precompiled for Linux or macOS</a></h2>
<p>The easiest way to install Gleam on Linux and Apple macOS is to download a
prebuilt version of the compiler from the <a href="https://github.com/lpil/gleam/releases">GitHub release
page</a>.</p>
<h2><a class="header" href="#asdf-version-manager" id="asdf-version-manager">asdf version manager</a></h2>
<p><a href="https://github.com/asdf-vm/asdf">asdf</a> is a tool for installing and managing
multiple version of programming languages at the same time. Install the
<a href="https://github.com/vic/asdf-gleam">asdf-gleam plugin</a> to manage Gleam with
asdf.</p>
<h2><a class="header" href="#arch-linux" id="arch-linux">Arch Linux</a></h2>
<p>Gleam is available through the <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository">Arch User Repository</a>
as package <code>gleam</code>. You can use your prefered <a href="https://wiki.archlinux.org/index.php/AUR_helpers">helper</a>
to install it or clone it for manual build from <a href="https://aur.archlinux.org/gleam.git">https://aur.archlinux.org/gleam.git</a>.</p>
<h2><a class="header" href="#build-from-source" id="build-from-source">Build from source</a></h2>
<p>The compiler is written in the Rust programming language and so if you wish to
build Gleam from source you will need to <a href="https://www.rust-lang.org/tools/install">install the Rust
compiler</a>.</p>
<pre><code class="language-sh"># Download the Gleam source code git repository
cd /tmp
git clone https://github.com/lpil/gleam.git --branch v0.2.0
cd gleam

# Build the Gleam compiler. This will take some time!
make install

# Verify the compiler is installed
# Prints &quot;gleam $VERSION&quot;
gleam --version
</code></pre>
<h1><a class="header" href="#installing-erlang" id="installing-erlang">Installing Erlang</a></h1>
<p>Gleam compiles to Erlang code, so Erlang needs to be installed to run Gleam
code.</p>
<p>Precompiled builds for many popular operating systems can be downloaded from
the <a href="https://www.erlang-solutions.com/resources/download.html">Erlang solutions website</a>,</p>
<p>Guides for installing Erlang on specific operating systems can be found below,
as well as information on installing multiple versions of Erlang at once using
version manager tools.</p>
<p>Once Erlang has been installed you can check it is working by typing <code>erl -version</code> in your computer's terminal. You will see version information like
this if all is well:</p>
<pre><code>$ erl -version
Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 10.1
</code></pre>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<h4><a class="header" href="#debian-linux" id="debian-linux">Debian Linux</a></h4>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<h4><a class="header" href="#ubuntu-linux" id="ubuntu-linux">Ubuntu Linux</a></h4>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<h3><a class="header" href="#mac-os-x" id="mac-os-x">Mac OS X</a></h3>
<h4><a class="header" href="#using-homebrew" id="using-homebrew">Using Homebrew</a></h4>
<p>With <a href="https://brew.sh">Homebrew</a> installed run the following:</p>
<pre><code class="language-sh">brew update
brew install erlang
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<h4><a class="header" href="#using-chocolatey" id="using-chocolatey">Using Chocolatey</a></h4>
<p>With <a href="https://chocolatey.org/">Chocolatey</a> installed on your computer run the
following:</p>
<pre><code>choco install erlang
</code></pre>
<h3><a class="header" href="#using-version-managers" id="using-version-managers">Using version managers</a></h3>
<h4><a class="header" href="#asdf" id="asdf">asdf</a></h4>
<p>The asdf version manager has a plugin for installing Erlang. Installation and
usage instructions can be found here:</p>
<ul>
<li><a href="https://github.com/asdf-vm/asdf">https://github.com/asdf-vm/asdf</a></li>
<li><a href="https://github.com/asdf-vm/asdf-erlang">https://github.com/asdf-vm/asdf-erlang</a></li>
</ul>
<h1><a class="header" href="#editor-support" id="editor-support">Editor support</a></h1>
<p>Gleam plugins are available for several popular editors. If one exists for
your editor of choice consider installing it for syntax highlighting and other
niceties.</p>
<ul>
<li><strong>Vim</strong> - <a href="https://github.com/gleam-lang/gleam.vim">https://github.com/gleam-lang/gleam.vim</a></li>
<li><strong>Emacs</strong> - <a href="https://github.com/MainShayne233/gleam-mode">https://github.com/MainShayne233/gleam-mode</a></li>
<li><strong>Visual Studio Code</strong> - <a href="https://github.com/rawburt/vscode-gleam-syntax">https://github.com/rawburt/vscode-gleam-syntax</a></li>
</ul>
<h1><a class="header" href="#creating-a-project" id="creating-a-project">Creating a project</a></h1>
<h2><a class="header" href="#installing-the-rebar3-build-tool" id="installing-the-rebar3-build-tool">Installing the rebar3 build tool</a></h2>
<p><strong>Note</strong>: Gleam's tooling is very young and in a state of flux. Expect rough
edges and breaking changes to come.</p>
<p>The Gleam compiler can build Gleam projects that are managed with the standard
Erlang build tool, rebar3. If you don't have rebar3 installed please <a href="https://www.rebar3.org/">install
it now</a>.</p>
<h2><a class="header" href="#generating-a-project" id="generating-a-project">Generating a project</a></h2>
<p>Now a project can be generated like so:</p>
<pre><code class="language-sh">gleam new my_fantastic_project
cd my_fantastic_project
</code></pre>
<p>You'll now have a project with this structure:</p>
<pre><code>.
├── gleam.toml
├── LICENSE
├── README.md
├── rebar.config
├── src
│   ├── my_fantastic_project.app.src
│   └── my_fantastic_project.gleam
└── test
    └── my_fantastic_project_test.gleam

2 directories, 7 files
</code></pre>
<p>The project is managed and built using rebar3, the standard Erlang build tool.
Here are some commonly used commands rebar3 commands that you can use with
your new project:</p>
<pre><code class="language-sh"># Run an interactive shell with your code loaded (Erlang syntax)
rebar3 shell

# Run the eunit tests
rebar3 eunit
</code></pre>
<p>More information can be found on the <a href="https://www.rebar3.org/docs">rebar3 documentation website</a>.</p>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>Want to see some Gleam code? See the <a href="getting-started/./example-projects.html">example projects</a>.</p>
<p>Looking to learn the language? Check out the <a href="getting-started/../tour">language tour</a>.</p>
<p>Need ideas for a project? We have a <a href="https://github.com/gleam-lang/suggestions/issues?q=is%3Aopen+is%3Aissue+label%3Aarea%3Alibraries">list of libraries</a> that need
writing.</p>
<h1><a class="header" href="#example-projects" id="example-projects">Example projects</a></h1>
<p>When learning a new language it can often be used to have example code to
refer to and learn from, so here's some examples:</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomgleam-langexample-url-shortenertiny-url-shortenera" id="a-hrefhttpsgithubcomgleam-langexample-url-shortenertiny-url-shortenera"><a href="https://github.com/gleam-lang/example-url-shortener">Tiny: URL shortener</a></a></h2>
<p>A simple HTML serving web application that takes URLs and gives the user a
shorter URL to use in its place.</p>
<p>Uses the Elli web server and the Postgresql database via the epgsql client.</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomlpilgleamtreemastergleam_stdlibthe-gleam-standard-librarya" id="a-hrefhttpsgithubcomlpilgleamtreemastergleam_stdlibthe-gleam-standard-librarya"><a href="https://github.com/lpil/gleam/tree/master/gleam_stdlib">The Gleam standard library</a></a></h2>
<p>A collection of modules for working with the common data structures of Gleam.
Makes heavy use of Erlang FFI.</p>
<h1><a class="header" href="#language-tour" id="language-tour">Language Tour</a></h1>
<p>In this chapter we explore the fundamentals of the Gleam language, namely its
syntax, core data structures, flow control features, and static type system.</p>
<p>After completion the reader should know enough to start reading and writing
Gleam code, assuming they have some prior programming experience.</p>
<p>In some section we touch on the runtime representation of various features.
This is useful for programmers with Erlang or Elixir experience who wish to
use Gleam alongside these languages. If you are using Gleam alone this
information can be safely ignored.</p>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>Gleam allows you to write comments in your code.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-rust noplaypen">// Hello, world!
</code></pre>
<p>In Gleam, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you’ll need to include
<code>//</code> on each line, like this:</p>
<pre><code class="language-rust noplaypen">// Hello, world! I have a lot to say, so much that it will take multiple
// lines of text. Therefore, I will start each line with // to denote it
// as part of a multi-line comment.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y // here we are adding two values together
}
</code></pre>
<p>Comments may also be indented:</p>
<pre><code class="language-rust noplaypen">
pub fn multiply(x, y) {
  // here we are multiplying x by y
  x * y 
}
</code></pre>
<h1><a class="header" href="#string" id="string">String</a></h1>
<p>Gleam's has UTF-8 binary strings, written as text surrounded by double quotes.</p>
<pre><code class="language-rust noplaypen">&quot;Hello, Gleam!&quot;
</code></pre>
<p>Strings can span multiple lines.</p>
<pre><code class="language-rust noplaypen">&quot;Hello
Gleam!&quot;
</code></pre>
<p>Special characters such as <code>&quot;</code> need to be escaped with a <code>\</code> character.</p>
<pre><code class="language-rust noplaypen">&quot;Here is a double quote -&gt; \&quot; &lt;-&quot;
</code></pre>
<h1><a class="header" href="#bool" id="bool">Bool</a></h1>
<p>A Bool can be either <code>True</code> or <code>False</code>.</p>
<p>Gleam defines a handful of operators that work with Bools.</p>
<pre><code class="language-rust noplaypen">False &amp;&amp; False // =&gt; False
False &amp;&amp; True  // =&gt; False
True &amp;&amp; False  // =&gt; False
True &amp;&amp; True   // =&gt; True

False || False // =&gt; False
False || True  // =&gt; True
True || False  // =&gt; True
True || True   // =&gt; True
</code></pre>
<p><code>&amp;&amp;</code> and <code>||</code> are <em>short circuiting</em>, meaning they don't evaluate the right
hand side if they don't have to.</p>
<p><code>&amp;&amp;</code> evaluates the right hand side if the left hand side is <code>True</code>.</p>
<p><code>||</code> evaluates the right hand side if the left hand side is <code>False</code>.</p>
<h2><a class="header" href="#erlang-interop" id="erlang-interop">Erlang interop</a></h2>
<p>While written in the code using a capital letter, they are represented at
runtime with the atoms <code>true</code> and <code>false</code>, making them compatible with Elixir
and Erlang's booleans.</p>
<p>This is important if you want to use Gleam and Elixir or Erlang together in
one project.</p>
<pre><code class="language-rust noplaypen">// Gleam
True
False
</code></pre>
<pre><code class="language-erlang">% Erlang
true.
false.
</code></pre>
<h1><a class="header" href="#int-and-float" id="int-and-float">Int and Float</a></h1>
<p>Gleam's main number types are Int and Float.</p>
<h2><a class="header" href="#ints" id="ints">Ints</a></h2>
<p>Ints are &quot;whole&quot; numbers.</p>
<pre><code class="language-rust noplaypen">1
2
-3
4001
</code></pre>
<p>Gleam has several operators that work with Ints, all of which return Ints.</p>
<pre><code class="language-rust noplaypen">1 + 1 // =&gt; 2
5 - 1 // =&gt; 4
5 / 2 // =&gt; 2
3 * 3 // =&gt; 9
5 % 2 // =&gt; 1
</code></pre>
<h2><a class="header" href="#floats" id="floats">Floats</a></h2>
<p>Floats are numbers that have a decimal point.</p>
<pre><code class="language-rust noplaypen">1.5
2.0
-0.1
</code></pre>
<p>Floats also have their own set of operators.</p>
<pre><code class="language-rust noplaypen">1.0 +. 1.4 // =&gt; 2.4
5.0 -. 1.5 // =&gt; 3.5
5.0 /. 2.0 // =&gt; 2.5
3.0 *. 3.1 // =&gt; 9.3
</code></pre>
<h1><a class="header" href="#let-bindings" id="let-bindings">Let bindings</a></h1>
<p>A value can be given a name using <code>let</code>. Names can be reused by later let
bindings, but the values contained are <em>immutable</em>, meaning the values
themselves cannot be changed.</p>
<pre><code class="language-rust noplaypen">let x = 1
let y = x
let x = 2

x  // =&gt; 2
y  // =&gt; 1
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples are an ordered collection of elements of a fixed size. Each element can
be of a different type.</p>
<pre><code class="language-rust noplaypen">{&quot;Cat&quot;, True}  // Type {String, Bool}
{1, 2.0, &quot;3&quot;}  // Type {Int, Float, String}
</code></pre>
<p>Contained values can be extracted from structs using a let binding.</p>
<pre><code class="language-rust noplaypen">let values = {1, 2.0}
let {x, y} = values

x  // =&gt; 1
y  // =&gt; 2.0
</code></pre>
<h1><a class="header" href="#list" id="list">List</a></h1>
<p>Lists are ordered collections of values. They're one of the most common data
structures in Gleam.</p>
<p>Lists are <em>homogeneous</em>, meaning all the elements of a List must be of the
same type. Attempting to construct a list of multiple types of element will
result in the compiler presenting a type error.</p>
<pre><code class="language-rust noplaypen">[1, 2, 3, 4]  // List(Int)
[1.22, 2.30]  // List(Float)
[1.22, 3, 4]  // Type error!
</code></pre>
<p>Prepending to a list is very fast, and is the preferred way to add new values.</p>
<pre><code class="language-rust noplaypen">[1 | [2, 3]]  // =&gt; [1, 2, 3]
</code></pre>
<p>Note that as all data structures in Gleam are immutable so prepending to a
list does not change the original list, instead it efficiently creates a new
list with the new additional element.</p>
<pre><code class="language-rust noplaypen">let x = [2, 3]
let y = [1 | x]


x  // =&gt; [2, 3]
y  // =&gt; [1, 2, 3]
</code></pre>
<h1><a class="header" href="#case" id="case">Case</a></h1>
<p>The <code>case</code> expression is the most common kind of flow control in Gleam code. It
allows us to say &quot;if the data has this shape then do that&quot;, which we call
<em>pattern matching</em>.</p>
<p>Here we match on an <code>Int</code> and return a specific string for the values 0, 1,
and 2. The final pattern <code>n</code> matches any other value that did not match any of
the previous patterns.</p>
<pre><code class="language-rust noplaypen">case some_number {
| 0 -&gt; &quot;Zero&quot;
| 1 -&gt; &quot;One&quot;
| 2 -&gt; &quot;Two&quot;
| n -&gt; &quot;Some other number&quot; // This matches anything
}
</code></pre>
<p>Pattern matching on a <code>Bool</code> value is the Gleam alternative to the <code>if else</code>
statement found in other languages.</p>
<pre><code class="language-rust noplaypen">case some_bool {
| True -&gt; &quot;It's true!&quot;
| False -&gt; &quot;It's not true.&quot;
}
</code></pre>
<p>Gleam's <code>case</code> is an expression, meaning it returns a value and can be used
anywhere we would use a value. For example, we can name the value of a case
expression with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">let description =
  case True {
  | True -&gt; &quot;It's true!&quot;
  | False -&gt; &quot;It's not true.&quot;
  }

description  // =&gt; &quot;It's true!&quot;
</code></pre>
<h2><a class="header" href="#destructuring" id="destructuring">Destructuring</a></h2>
<p>Like <code>let</code> bindings a <code>case</code> expression can be used to destructure values that
contain other values, such as tuples and lists.</p>
<pre><code class="language-rust noplaypen">case xs {
| [] -&gt; &quot;This list is empty&quot;
| [a] -&gt; &quot;This list has 1 element&quot;
| [a, b] -&gt; &quot;This list has 2 element&quot;
| other -&gt; &quot;This list has more than 2 elements&quot;
}
</code></pre>
<p>It's not just the top level data structure that can be pattern matches,
contained values can also be matched. This gives <code>case</code> the ability to
concisely express flow control that might be verbose without pattern matching.</p>
<pre><code class="language-rust noplaypen">case xs {
| [[]] -&gt; &quot;The only element is an empty list&quot;
| [[] | _] -&gt; &quot;The 1st element is an empty list&quot;
| [[4] | _] -&gt; &quot;The 1st element is a list of the number 4&quot;
| other -&gt; &quot;Something else&quot;
}
</code></pre>
<pre><code class="language-rust noplaypen">case xs {
| {1, _} -&gt; &quot;The 1st element is 1&quot;
| {_, 1} -&gt; &quot;The 2nd element is 1&quot;
| other -&gt; &quot;Something else&quot;
}
</code></pre>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<h2><a class="header" href="#named-functions" id="named-functions">Named functions</a></h2>
<p>Named functions in Gleam are defined using the <code>pub fn</code> keywords.</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y
}

pub fn multiply(x, y) {
  x * y
}
</code></pre>
<p>Functions in Gleam are first class values and so can be assigned to variables,
passed to functions, or anything else you might do with any other data type.</p>
<pre><code class="language-rust noplaypen">// This function takes a function as an argument
pub fn twice(f, x) {
  f(f(x))
}

pub fn add_one(x) {
  x + 1
}

pub fn add_two(x) {
  twice(add_one, x)
}
</code></pre>
<h2><a class="header" href="#type-annotations" id="type-annotations">Type annotations</a></h2>
<p>Function arguments can be optionally be annotated with their type. The
compiler will check these annotations and ensure they are correct.</p>
<pre><code class="language-rust noplaypen">fn identity(x: Int) -&gt; Int {
  x
}
</code></pre>
<p>Without an annotation this identity function would have have the inferred type
<code>fn(a) -&gt; a</code>, but the type annotation on the argument results in the type
of the function being <code>fn(Int) -&gt; Int</code>. This shows how type annotations can be
used to create functions with types less general than the compiler may have
inferred otherwise.</p>
<h2><a class="header" href="#anonymous-functions" id="anonymous-functions">Anonymous functions</a></h2>
<p>Anonymous functions can be defined with a similar syntax.</p>
<pre><code class="language-rust noplaypen">pub fn run() {
  let add = fn(x, y) { x + y }

  add(1, 2)
}
</code></pre>
<h2><a class="header" href="#function-capturing" id="function-capturing">Function capturing</a></h2>
<p>There is a shorthand syntax for creating anonymous functions that take one
argument and call another function. The <code>_</code> is used to indicate where the
argument should be passed.</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y
}

pub fn run() {
  let add_one = add(1, _)

  add_one(2)
}
</code></pre>
<p>The function capture syntax is often used with the pipe operator to create
a series of transformations on some data.</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y
}

pub fn run() {
  // This is the same as add(add(add(1, 3), 6), 9)
  1
  |&gt; add(_, 3)
  |&gt; add(_, 6)
  |&gt; add(_, 9)
}
</code></pre>
<h1><a class="header" href="#module" id="module">Module</a></h1>
<p>Gleam programs are made up of bundles of functions and types called modules.
Each module has its own namespace and can export types and values to be used
by other modules in the program.</p>
<pre><code class="language-rust noplaypen">// inside src/nasa/rocket_ship.gleam

fn count_down() {
  &quot;3... 2... 1...&quot;
}

fn blast_off() {
  &quot;BOOM!&quot;
}

pub fn launch() {
  [
    count_down(),
    blast_off(),
  ]
}
</code></pre>
<p>Here we can see a module named <code>nasa/rocket_ship</code>, the name determined by the
filename <code>src/nasa/rocket_ship.gleam</code>. Typically all the modules for one
project would live within a directory with the name of the project, such as
<code>nasa</code> in this example.</p>
<p>For the functions <code>count_down</code> and <code>blast_off</code> we have omitted the <code>pub</code>
keyword, so these functions are <em>private</em> module functions. They can only be
called by other functions within the same module.</p>
<h2><a class="header" href="#import" id="import">Import</a></h2>
<p>To use functions or types from another module we need to import them using the
<code>import</code> keyword.</p>
<pre><code class="language-rust noplaypen">// inside src/nasa/moon_base.gleam

import nasa/rocket_ship

pub fn explore_space() {
  rocket_ship:launch()
}
</code></pre>
<p>The statement <code>import nasa/rocket_ship</code> creates a new variable with the name
<code>rocket_ship</code> and the value of the <code>rocket_ship</code> module.</p>
<p>In the <code>explore_space</code> function we call the imported module's public <code>launch</code>
function using the <code>:</code> operator.
If we had attempted to call <code>count_down</code> it would result in a compile time
error as this function is private in the <code>rocket_ship</code> module.</p>
<h2><a class="header" href="#named-import" id="named-import">Named import</a></h2>
<p>It is also possible to give a module a custom name when importing it using the
<code>as</code> keyword.</p>
<pre><code class="language-rust noplaypen">import unix/cat
import animal/cat as kitty
</code></pre>
<p>This may be useful to differentiate between multiple modules that would have
the same default name when imported.</p>
<h2><a class="header" href="#first-class-modules" id="first-class-modules">First class modules</a></h2>
<p>Modules in Gleam are first class values and can be assigned to variables,
passed to functions, or anything else that we can do with regular values.</p>
<pre><code class="language-rust noplaypen">import nasa/rocket_ship
import nasa/new_website
import nasa/navy_boat

pub fn perform_launch(some_module) {
  some_module:launch()
}

pub fn run() {
  perform_launch(rocket_ship)
  perform_launch(new_website)
  perform_launch(navy_boat)
}
</code></pre>
<p>Here we have define a function that takes a module as an argument and then
called it with various different modules.</p>
<p>The <code>perform_launch</code> function doesn't care what module it takes, so long as it
has a public function called <code>launch</code> that takes no arguments.</p>
<h1><a class="header" href="#map" id="map">Map</a></h1>
<p>Gleam's maps are a collection of names and values where each value can be
of any type.</p>
<pre><code class="language-rust noplaypen">{
  name = &quot;Rex&quot;,
  size = 40,
}
</code></pre>
<h2><a class="header" href="#accessing-field-values" id="accessing-field-values">Accessing field values</a></h2>
<p>Map values can be accessed using the <code>map.field_name</code> syntax.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }
let name = pup.name

name  // =&gt; &quot;Rex&quot;
</code></pre>
<h2><a class="header" href="#inserting-field-values" id="inserting-field-values">Inserting field values</a></h2>
<p>A new map with updated or additional fields can be created using the
<code>{ map | field_name = value }</code> update syntax.</p>
<p>The updated map fields do not have to have the same types as the original
fields.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }
let dog = { pup | size = 70, playful = True }

pup  // { name = &quot;Rex&quot;, size = 40 }
dog  // { name = &quot;Rex&quot;, size = 70, playful = True }
</code></pre>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<p>The type of a map depends upon the names and types of its fields.</p>
<pre><code class="language-rust noplaypen">{ name = &quot;Rex&quot; }             // Type { name = String }
{ name = &quot;Rex&quot;, size = 40 }  // Type { name = String, size = Int }
</code></pre>
<p>The Gleam compiler keeps tracks of what fields and values each map has and
will present a compile time error if you try to use a map field that does
not exist or has the incorrect type.</p>
<pre><code class="language-rust noplaypen">let pup = { name = &quot;Rex&quot;, size = 40 }

pup.address   // Compile time error! Unknown field
pup.name + 1  // Compile time error! Wrong type
</code></pre>
<h3><a class="header" href="#parameterised-map-fields" id="parameterised-map-fields">Parameterised map fields</a></h3>
<p>Gleam's type system aims to be as permissive when it comes to maps passed
to functions. Take this function for example.</p>
<pre><code class="language-rust noplaypen">fn get_following_year(map) {
  map.year + 1
}
</code></pre>
<p>The type of this function is <code>fn({ a | year = Int }) -&gt; Int</code>.</p>
<p>The <code>a |</code> in <code>{ a | year = Int }</code> means &quot;any other fields&quot;, so this function
can be called with any map so long as the map has a <code>year</code> field that
has an <code>Int</code> value.</p>
<pre><code class="language-rust noplaypen">let date = { day = 5, month: 1, year = 2019 }
let book = { title = &quot;Sabriel&quot;, year = 1995 }
let soup = { kind = &quot;Tomato&quot;, spicy = False }
let wine = { kind = &quot;Fancy!&quot;, year = &quot;Good&quot; }

get_following_year(date)  // =&gt; 2020
get_following_year(book)  // =&gt; 1996
get_following_year(soup)  // Compile time error! No year field
get_following_year(wine)  // Compile time error! Wrong field type
</code></pre>
<h2><a class="header" href="#erlang-interop-1" id="erlang-interop-1">Erlang interop</a></h2>
<p>At runtime Gleam maps are Erlang maps with atom keys. They are similar to
Elixir's structs, but do not need to be declared prior to being used.</p>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Enums in Gleam are a way of modeling data that can be one of a few different
variants. They must be declared before use, and the names of variants must be
unique for the given module.</p>
<p>We've seen an enum already in this chapter- <code>Bool</code>.</p>
<p>Bool is defined like this:</p>
<pre><code class="language-rust noplaypen">// A Bool is a value that is either `True` or `False`
enum Bool =
  | True
  | False
</code></pre>
<p>Enum variants can also contain other values, and these values can be extracted
using a let binding.</p>
<pre><code class="language-rust noplaypen">enum User =
  | LoggedIn(String)  // A logged in user with a name
  | Guest             // A guest user with no details
</code></pre>
<pre><code class="language-rust noplaypen">let sara = LoggedIn(&quot;Sara&quot;)
let rick = LoggedIn(&quot;Rick&quot;)
let visitor = Guest
</code></pre>
<h2><a class="header" href="#destructuring-1" id="destructuring-1">Destructuring</a></h2>
<p>When given an enum we can pattern match on it to determine which variant it is
and to assign names to any contained values.</p>
<pre><code class="language-rust noplaypen">fn get_name(user) {
  case user {
  | LoggedIn(name) -&gt; name
  | Guest -&gt; &quot;Guest user&quot;
  }
}
</code></pre>
<p>Enums can also be destructured with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">enum Score =
  | Points(Int)
</code></pre>
<pre><code class="language-rust noplaypen">let score = Points(50)
let Points(p) = score

p // =&gt; 50
</code></pre>
<h2><a class="header" href="#erlang-interop-2" id="erlang-interop-2">Erlang interop</a></h2>
<p>At runtime enum variants with no contained values become atoms. The atoms are
written in <code>snake_case</code> rather than <code>CamelCase</code> so <code>LoggedIn</code> becomes
<code>logged_in</code>.</p>
<p>Enum variants with contained values become tuples with a tag atom.</p>
<pre><code class="language-rust noplaypen">// Gleam
Guest
LoggedIn(&quot;Kim&quot;)
</code></pre>
<pre><code># Elixir
:guest
{:logged_in, &quot;Kim&quot;}
</code></pre>
<pre><code>% Erlang
guest.
{logged_in, &lt;&lt;&quot;Kim&quot;&gt;&gt;}.
</code></pre>
<h1><a class="header" href="#external-function" id="external-function">External function</a></h1>
<p>Gleam is just one of many languages on the Erlang virtual machine and at times
we may want to use functions from these other languages in our Gleam programs.
To enable this Gleam allows the importing of <em>external functions</em>, which may
be written in any BEAM language.</p>
<p>External functions are typically written in a different language with a
different type system, so the compiler is unable to determine the type of the
function and instead the programmer must inform the compiler the type.</p>
<p>Gleam trusts that the type given is correct so an inaccurate type annotation
can result in unexpected behaviour and crashes at runtime. Be careful!</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>The Erlang <code>rand</code> module has a function named <code>uniform</code> that takes no
arguments and returns a <code>Float</code>.</p>
<p>The Elixir module <code>IO</code> has a function named <code>inspect</code> that takes any value,
prints it, and returns the same value.</p>
<p>If we want to import these functions and use them in our program we would do
so like this:</p>
<pre><code class="language-rust noplaypen">pub external fn random_float() -&gt; Float = &quot;rand&quot; &quot;uniform&quot;

// Elixir modules start with `Elixir.`
pub external fn inspect(a) -&gt; a = &quot;Elixir.IO&quot; &quot;inspect&quot;
</code></pre>
<h1><a class="header" href="#external-type" id="external-type">External type</a></h1>
<p>In addition to importing external functions we can also import external types.
Gleam knows nothing about the runtime representation of these types and so
they cannot be pattern matched on, but they can be used with external
functions that know how to work with them.</p>
<p>Here is an example of importing a <code>Queue</code> data type and some functions from
Erlang's <code>queue</code> module to work with the new <code>Queue</code> type.</p>
<pre><code class="language-rust noplaypen">pub external type Queue(a)

pub external fn new() -&gt; Queue(a) = &quot;queue&quot; &quot;new&quot;

pub external fn length(Queue(a)) -&gt; Int = &quot;queue&quot; &quot;len&quot;

pub external fn push(Queue(a), a) -&gt; Queue(a) = &quot;queue&quot; &quot;in&quot;
</code></pre>
<h1><a class="header" href="#faqs" id="faqs">FAQs</a></h1>
<ul>
<li><a href="faqs.html#why-is-the-compiler-written-in-rust">Why is the compiler written in Rust?</a></li>
<li><a href="faqs.html#will-gleam-have-type-classes">Will Gleam have type classes?</a></li>
<li><a href="faqs.html#how-is-message-passing-typed">How is message passing typed?</a></li>
<li><a href="faqs.html#how-does-gleam-compare-to-alpaca">How does Gleam compare to Alpaca?</a></li>
<li><a href="faqs.html#should-i-put-gleam-in-production">Should I put Gleam in production?</a></li>
<li><a href="faqs.html#is-it-good">Is it good?</a></li>
</ul>
<h2><a class="header" href="#why-is-the-compiler-written-in-rust" id="why-is-the-compiler-written-in-rust">Why is the compiler written in Rust?</a></h2>
<p>Prototype versions of the Gleam compiler was written in Erlang, but a switch was
made to Rust as the lack of static types was making refactoring a slow and
error prone process. A full Rust rewrite of the prototype resulted in the
removal of a lot of tech debt and bugs, and the performance boost is nice too!</p>
<p>One day Gleam may have a compiler written in Gleam, but for now we are focused
on developing other areas of the language such as libraries, tooling, and
documentation.</p>
<h2><a class="header" href="#will-gleam-have-type-classes" id="will-gleam-have-type-classes">Will Gleam have type classes?</a></h2>
<p>Some form of ad-hoc polymorphism could be a good addition to the ergonomics of
the language, though what shape that may take is unclear. Type classes are one
option, OCaml style implicit modules are another, or perhaps it'll be
something else entirely.</p>
<h2><a class="header" href="#how-is-message-passing-typed" id="how-is-message-passing-typed">How is message passing typed?</a></h2>
<p>Gleam doesn't currently have first class support for the BEAM's
concurrency primitives such as <code>receive</code>, <code>send</code>, and <code>spawn</code>. This is because
research is still ongoing as to the best way to apply a strong type system to
them while still enabling established OTP patterns. For now these primitives
should be used via the Erlang FFI, making them dynamically typed.</p>
<p>Many OTP patterns such as <code>gen_server</code> are functional in nature and don't
require direct use of these primitives so these behaviours can be implemented
in Gleam today.</p>
<h2><a class="header" href="#how-does-gleam-compare-to-alpaca" id="how-does-gleam-compare-to-alpaca">How does Gleam compare to Alpaca?</a></h2>
<p><a href="https://github.com/alpaca-lang/alpaca">Alpaca</a> is similar to Gleam in that it is a statically typed language
for the Erlang VM that is inspired by the ML family of languages. It's a
wonderful project and we hope they are wildly successful!</p>
<p>Here's a non-exhaustive list of differences:</p>
<ul>
<li>Alpaca functions are auto-curried, Gleam's are not.</li>
<li>Alpaca's unions can be untagged, with Gleam all variants in an enum need a
name.</li>
<li>Alpaca's compiler is written in Erlang, Gleam's is written in Rust.</li>
<li>Alpaca's syntax is closer to ML family languages, Gleam's is closer to C
family languages.</li>
<li>Alpaca compiles to Core Erlang, Gleam compiles to regular Erlang.</li>
</ul>
<p>Alpaca is great, check it out! :)</p>
<h2><a class="header" href="#should-i-put-gleam-in-production" id="should-i-put-gleam-in-production">Should I put Gleam in production?</a></h2>
<p>Probably not. Gleam is a very young language and there may be all kinds of
problems and breaking changes down the line.</p>
<p>Having said that, the Erlang VM is extremely mature and well tested, and if
you decide to move away from Gleam the language you can compile your code to
Erlang and maintain that in future.</p>
<h2><a class="header" href="#is-it-good" id="is-it-good">Is it good?</a></h2>
<p>Yes, I think so. :)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
