---
source: compiler-core/src/language_server/tests/rename.rs
expression: "import mod as module\n\nfn func(\n  arg: module.Type,\n  arg2: module.GenericType(module.Type),\n  arg3: #(module.GenericType(module.Type), module.Type),\n  arg4: List(module.Type),\n  arg5: fn(module.Type) -> module.Type\n) {\n  module.fn1()\n  arg5(module.Variant1)\n\n  let _: module.Type = module.Variant1\n  let _: module.GenericType(module.Type) = module.Node(module.Variant1, module.Leaf)\n  let _ = module.const1\n  let _ = module.fn1\n\n  let _: #(module.Type) = #(module.Variant1)\n  let _: #(module.GenericType(module.Type)) = #(module.Node(module.Variant1, module.Leaf))\n  let _ = #(module.const1)\n  let _ = #(module.fn1())\n  let _ = #(module.fn1)\n\n  let _: List(module.Type) = [module.Variant1]\n  let _: List(module.GenericType(module.Type)) = [module.Node(module.Variant1, module.Leaf)]\n  let _ = [module.const1]\n  let _ = [module.fn1()]\n  let _ = [module.fn1]\n\n  let _: fn(module.Type) -> module.Type = fn(arg: module.Type) -> module.Type { arg }\n  let _: fn(module.GenericType(module.Type)) -> module.GenericType(module.Type) = fn(arg: module.GenericType(module.Type)) -> module.GenericType(module.Type) { arg }\n\n  let _ = <<module.const2:bits, module.const2:bits>>\n\n  let _ = module.const3 <> module.const3\n\n  case arg {\n    module.Variant1 -> todo\n    module.Variant2(3) -> todo\n    module.Variant2(_) -> todo\n    module.Variant2(..) -> todo\n  }\n  case arg2 {\n    module.Node(_, module.Node(_, _)) -> todo\n    module.Node(_, _) -> todo\n    module.Leaf -> todo\n  }\n  case arg3 {\n    #(module.Node(_, module.Leaf), module.Variant1) -> todo\n    _ -> todo\n  }\n  case arg4 {\n    [module.Variant1, ..] -> todo\n    _ if module.const1 == module.const1 -> todo\n    _ -> todo\n  }\n  let mod = Record(false)\n  echo mod.bool\n}\n\nconst c1: module.Type = module.Variant1\nconst c2: module.GenericType(module.Type) = module.Node(module.Variant1, module.Leaf)\nconst c3 = module.const1\nconst c4 = module.fn1\nconst c5: #(module.Type, Int, fn() -> Nil) = #(module.Variant1, module.const1, module.fn1)\nconst c6: List(module.Type) = [module.Variant1]\nconst c7 = [module.const1]\nconst c8 = [module.fn1]\nconst c9 = <<module.const2:bits>>\nconst c10 = module.const3 <> module.const3\ntype Type1 { Var(module.Type) }\ntype Type2 = module.GenericType(module.Type)\ntype Record { Record (bool: Bool) }"
---
----- BEFORE RENAME
-- mod.gleam
pub fn fn1() { Nil }
pub const const1 = 5
pub const const2 = <<0:8>>
pub const const3 = "Hello"
pub type Type { Variant1 Variant2(Int) }
pub type GenericType(inner) { Node(inner, GenericType(inner)) Leaf }

-- app.gleam
import mod as module
              ↑▔▔▔▔▔

fn func(
  arg: module.Type,
  arg2: module.GenericType(module.Type),
  arg3: #(module.GenericType(module.Type), module.Type),
  arg4: List(module.Type),
  arg5: fn(module.Type) -> module.Type
) {
  module.fn1()
  arg5(module.Variant1)

  let _: module.Type = module.Variant1
  let _: module.GenericType(module.Type) = module.Node(module.Variant1, module.Leaf)
  let _ = module.const1
  let _ = module.fn1

  let _: #(module.Type) = #(module.Variant1)
  let _: #(module.GenericType(module.Type)) = #(module.Node(module.Variant1, module.Leaf))
  let _ = #(module.const1)
  let _ = #(module.fn1())
  let _ = #(module.fn1)

  let _: List(module.Type) = [module.Variant1]
  let _: List(module.GenericType(module.Type)) = [module.Node(module.Variant1, module.Leaf)]
  let _ = [module.const1]
  let _ = [module.fn1()]
  let _ = [module.fn1]

  let _: fn(module.Type) -> module.Type = fn(arg: module.Type) -> module.Type { arg }
  let _: fn(module.GenericType(module.Type)) -> module.GenericType(module.Type) = fn(arg: module.GenericType(module.Type)) -> module.GenericType(module.Type) { arg }

  let _ = <<module.const2:bits, module.const2:bits>>

  let _ = module.const3 <> module.const3

  case arg {
    module.Variant1 -> todo
    module.Variant2(3) -> todo
    module.Variant2(_) -> todo
    module.Variant2(..) -> todo
  }
  case arg2 {
    module.Node(_, module.Node(_, _)) -> todo
    module.Node(_, _) -> todo
    module.Leaf -> todo
  }
  case arg3 {
    #(module.Node(_, module.Leaf), module.Variant1) -> todo
    _ -> todo
  }
  case arg4 {
    [module.Variant1, ..] -> todo
    _ if module.const1 == module.const1 -> todo
    _ -> todo
  }
  let mod = Record(false)
  echo mod.bool
}

const c1: module.Type = module.Variant1
const c2: module.GenericType(module.Type) = module.Node(module.Variant1, module.Leaf)
const c3 = module.const1
const c4 = module.fn1
const c5: #(module.Type, Int, fn() -> Nil) = #(module.Variant1, module.const1, module.fn1)
const c6: List(module.Type) = [module.Variant1]
const c7 = [module.const1]
const c8 = [module.fn1]
const c9 = <<module.const2:bits>>
const c10 = module.const3 <> module.const3
type Type1 { Var(module.Type) }
type Type2 = module.GenericType(module.Type)
type Record { Record (bool: Bool) }


----- AFTER RENAME
-- mod.gleam
pub fn fn1() { Nil }
pub const const1 = 5
pub const const2 = <<0:8>>
pub const const3 = "Hello"
pub type Type { Variant1 Variant2(Int) }
pub type GenericType(inner) { Node(inner, GenericType(inner)) Leaf }

-- app.gleam
import mod as alias

fn func(
  arg: alias.Type,
  arg2: alias.GenericType(alias.Type),
  arg3: #(alias.GenericType(alias.Type), alias.Type),
  arg4: List(alias.Type),
  arg5: fn(alias.Type) -> alias.Type
) {
  alias.fn1()
  arg5(alias.Variant1)

  let _: alias.Type = alias.Variant1
  let _: alias.GenericType(alias.Type) = alias.Node(alias.Variant1, alias.Leaf)
  let _ = alias.const1
  let _ = alias.fn1

  let _: #(alias.Type) = #(alias.Variant1)
  let _: #(alias.GenericType(alias.Type)) = #(alias.Node(alias.Variant1, alias.Leaf))
  let _ = #(alias.const1)
  let _ = #(alias.fn1())
  let _ = #(alias.fn1)

  let _: List(alias.Type) = [alias.Variant1]
  let _: List(alias.GenericType(alias.Type)) = [alias.Node(alias.Variant1, alias.Leaf)]
  let _ = [alias.const1]
  let _ = [alias.fn1()]
  let _ = [alias.fn1]

  let _: fn(alias.Type) -> alias.Type = fn(arg: alias.Type) -> alias.Type { arg }
  let _: fn(alias.GenericType(alias.Type)) -> alias.GenericType(alias.Type) = fn(arg: alias.GenericType(alias.Type)) -> alias.GenericType(alias.Type) { arg }

  let _ = <<alias.const2:bits, alias.const2:bits>>

  let _ = alias.const3 <> alias.const3

  case arg {
    alias.Variant1 -> todo
    alias.Variant2(3) -> todo
    alias.Variant2(_) -> todo
    alias.Variant2(..) -> todo
  }
  case arg2 {
    alias.Node(_, alias.Node(_, _)) -> todo
    alias.Node(_, _) -> todo
    alias.Leaf -> todo
  }
  case arg3 {
    #(alias.Node(_, alias.Leaf), alias.Variant1) -> todo
    _ -> todo
  }
  case arg4 {
    [alias.Variant1, ..] -> todo
    _ if alias.const1 == alias.const1 -> todo
    _ -> todo
  }
  let mod = Record(false)
  echo mod.bool
}

const c1: alias.Type = alias.Variant1
const c2: alias.GenericType(alias.Type) = alias.Node(alias.Variant1, alias.Leaf)
const c3 = alias.const1
const c4 = alias.fn1
const c5: #(alias.Type, Int, fn() -> Nil) = #(alias.Variant1, alias.const1, alias.fn1)
const c6: List(alias.Type) = [alias.Variant1]
const c7 = [alias.const1]
const c8 = [alias.fn1]
const c9 = <<alias.const2:bits>>
const c10 = alias.const3 <> alias.const3
type Type1 { Var(alias.Type) }
type Type2 = alias.GenericType(alias.Type)
type Record { Record (bool: Bool) }
