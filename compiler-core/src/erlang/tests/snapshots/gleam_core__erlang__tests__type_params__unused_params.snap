---
source: compiler-core/src/erlang/tests/type_params.rs
expression: "\n        fn foo() {\n            let parent_subject = new_subject()\n            let assert Ok(call_subject) = receive(parent_subject)\n            let assert Ok(_) = try_call(call_subject, fn(subject) { #(1, subject) })\n        }\n\n        type Subject(message) {\n            Subject(message)\n        }\n\n        fn new_subject() -> Subject(message) {\n            todo\n        }\n\n        fn receive(subject: Subject(message)) -> Result(message, Nil) {\n            todo\n        }\n\n        type CallError(msg) {\n            CalleeDown(reason: String)\n            CallTimeout\n        }\n\n        fn try_call(\n            subject: Subject(request),\n            make_request: fn(Subject(response)) -> request\n        ) -> Result(response, CallError(response)) {\n            todo\n        }\n        "
---
-module(my@mod).
-compile([no_auto_import, nowarn_unused_vars, nowarn_unused_function, nowarn_nomatch]).

-export_type([subject/1, call_error/1]).

-type subject(I) :: {subject, I}.

-type call_error(J) :: {callee_down, binary()} |
    call_timeout |
    {gleam_phantom, J}.

-spec new_subject() -> subject(any()).
new_subject() ->
    erlang:error(#{gleam_error => todo,
            message => <<"This has not yet been implemented"/utf8>>,
            module => <<"my/mod"/utf8>>,
            function => <<"new_subject"/utf8>>,
            line => 13}).

-spec 'receive'(subject(N)) -> {ok, N} | {error, nil}.
'receive'(Subject) ->
    erlang:error(#{gleam_error => todo,
            message => <<"This has not yet been implemented"/utf8>>,
            module => <<"my/mod"/utf8>>,
            function => <<"receive"/utf8>>,
            line => 17}).

-spec try_call(subject(R), fun((subject(T)) -> R)) -> {ok, T} |
    {error, call_error(T)}.
try_call(Subject, Make_request) ->
    erlang:error(#{gleam_error => todo,
            message => <<"This has not yet been implemented"/utf8>>,
            module => <<"my/mod"/utf8>>,
            function => <<"try_call"/utf8>>,
            line => 29}).

-spec foo() -> {ok, any()} | {error, call_error(any())}.
foo() ->
    Parent_subject = new_subject(),
    _assert_subject = 'receive'(Parent_subject),
    {ok, Call_subject} = case _assert_subject of
        {ok, _} -> _assert_subject;
        _assert_fail ->
            erlang:error(#{gleam_error => let_assert,
                        message => <<"Assertion pattern match failed"/utf8>>,
                        value => _assert_fail,
                        module => <<"my/mod"/utf8>>,
                        function => <<"foo"/utf8>>,
                        line => 4})
    end,
    _assert_subject@1 = try_call(Call_subject, fun(Subject) -> {1, Subject} end),
    {ok, _} = case _assert_subject@1 of
        {ok, _} -> _assert_subject@1;
        _assert_fail@1 ->
            erlang:error(#{gleam_error => let_assert,
                        message => <<"Assertion pattern match failed"/utf8>>,
                        value => _assert_fail@1,
                        module => <<"my/mod"/utf8>>,
                        function => <<"foo"/utf8>>,
                        line => 5})
    end.
