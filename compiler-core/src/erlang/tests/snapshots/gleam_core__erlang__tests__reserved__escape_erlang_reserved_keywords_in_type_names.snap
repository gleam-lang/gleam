---
source: compiler-core/src/erlang/tests/reserved.rs
expression: "pub type After { TestAfter }\npub type And { TestAnd }\npub type Andalso { TestAndAlso }\npub type Band { TestBAnd }\npub type Begin { TestBegin }\npub type Bnot { TestBNot }\npub type Bor { TestBOr }\npub type Bsl { TestBsl }\npub type Bsr { TestBsr }\npub type Bxor { TestBXor }\npub type Case { TestCase }\npub type Catch { TestCatch }\npub type Cond { TestCond }\npub type Div { TestDiv }\npub type End { TestEnd }\npub type Fun { TestFun }\npub type If { TestIf }\npub type Let { TestLet }\npub type Maybe { TestMaybe }\npub type Not { TestNot }\npub type Of { TestOf }\npub type Or { TestOr }\npub type Orelse { TestOrElse }\npub type Query { TestQuery }\npub type Receive { TestReceive }\npub type Rem { TestRem }\npub type Try { TestTry }\npub type When { TestWhen }\npub type Xor { TestXor }"
---
----- SOURCE CODE
pub type After { TestAfter }
pub type And { TestAnd }
pub type Andalso { TestAndAlso }
pub type Band { TestBAnd }
pub type Begin { TestBegin }
pub type Bnot { TestBNot }
pub type Bor { TestBOr }
pub type Bsl { TestBsl }
pub type Bsr { TestBsr }
pub type Bxor { TestBXor }
pub type Case { TestCase }
pub type Catch { TestCatch }
pub type Cond { TestCond }
pub type Div { TestDiv }
pub type End { TestEnd }
pub type Fun { TestFun }
pub type If { TestIf }
pub type Let { TestLet }
pub type Maybe { TestMaybe }
pub type Not { TestNot }
pub type Of { TestOf }
pub type Or { TestOr }
pub type Orelse { TestOrElse }
pub type Query { TestQuery }
pub type Receive { TestReceive }
pub type Rem { TestRem }
pub type Try { TestTry }
pub type When { TestWhen }
pub type Xor { TestXor }

----- COMPILED ERLANG
-module(my@mod).
-compile([no_auto_import, nowarn_unused_vars, nowarn_unused_function, nowarn_nomatch, inline]).
-define(FILEPATH, "project/test/my/mod.gleam").
-export_type(['after'/0, 'and'/0, 'andalso'/0, 'band'/0, 'begin'/0, 'bnot'/0, 'bor'/0, 'bsl'/0, 'bsr'/0, 'bxor'/0, 'case'/0, 'catch'/0, 'cond'/0, 'div'/0, 'end'/0, 'fun'/0, 'if'/0, 'let'/0, 'maybe'/0, 'not'/0, 'of'/0, 'or'/0, 'orelse'/0, 'query'/0, 'receive'/0, 'rem'/0, 'try'/0, 'when'/0, 'xor'/0]).

-type 'after'() :: test_after.

-type 'and'() :: test_and.

-type 'andalso'() :: test_and_also.

-type 'band'() :: test_b_and.

-type 'begin'() :: test_begin.

-type 'bnot'() :: test_b_not.

-type 'bor'() :: test_b_or.

-type 'bsl'() :: test_bsl.

-type 'bsr'() :: test_bsr.

-type 'bxor'() :: test_b_xor.

-type 'case'() :: test_case.

-type 'catch'() :: test_catch.

-type 'cond'() :: test_cond.

-type 'div'() :: test_div.

-type 'end'() :: test_end.

-type 'fun'() :: test_fun.

-type 'if'() :: test_if.

-type 'let'() :: test_let.

-type 'maybe'() :: test_maybe.

-type 'not'() :: test_not.

-type 'of'() :: test_of.

-type 'or'() :: test_or.

-type 'orelse'() :: test_or_else.

-type 'query'() :: test_query.

-type 'receive'() :: test_receive.

-type 'rem'() :: test_rem.

-type 'try'() :: test_try.

-type 'when'() :: test_when.

-type 'xor'() :: test_xor.
