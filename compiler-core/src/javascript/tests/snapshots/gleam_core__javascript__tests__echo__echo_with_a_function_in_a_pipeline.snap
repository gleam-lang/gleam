---
source: compiler-core/src/javascript/tests/echo.rs
expression: "\npub fn main() {\n  [1, 2, 3]\n  |> echo wibble\n  |> wibble\n}\n\npub fn wibble(n) { n }\n"
---
import { toList, BitArray, List, UtfCodepoint, CustomType } from "../gleam.mjs";

export function wibble(n) {
  return n;
}

export function main() {
  let _pipe = toList([1, 2, 3]);
  let _pipe$1 = echo(wibble)(_pipe);
  return wibble(_pipe$1);
}

// Debug printing code

function echo(v) {
  function inspectString(str) {
    let new_str = '"';
    for (let i = 0; i < str.length; i++) {
      let char = str[i];
      if (char == "\n") new_str += "\\n";
      else if (char == "\r") new_str += "\\r";
      else if (char == "\t") new_str += "\\t";
      else if (char == "\f") new_str += "\\f";
      else if (char == "\\") new_str += "\\\\";
      else if (char == '"') new_str += '\\"';
      else if (char < " " || (char > "~" && char < "\u{00A0}")) {
        new_str += "\\u{" + char.charCodeAt(0).toString(16).toUpperCase().padStart(4, "0") + "}";
      } else {
        new_str += char;
      }
    }
    new_str += '"';
    return new_str;
  }

  function inspectDict(map) {
    let body = "dict.from_list([";
    let first = true;
    map.forEach((value, key) => {
      if (!first) body = body + ", ";
      body = body + "#(" + inspect(key) + ", " + inspect(value) + ")";
      first = false;
    });
    return body + "])";
  }

  function inspectCustomType(record) {
    const props = Object.keys(record)
      .map((label) => {
        const value = inspect(record[label]);
        return isNaN(parseInt(label)) ? `${label}: ${value}` : value;
      })
      .join(", ");
    return props ? `${record.constructor.name}(${props})` : record.constructor.name;
  }

  function inspectObject(v) {
    const name = Object.getPrototypeOf(v)?.constructor?.name || "Object";
    const props = [];
    for (const k of Object.keys(v)) {
      props.push(`${inspect(k)}: ${inspect(v[k])}`);
    }
    const body = props.length ? " " + props.join(", ") + " " : "";
    const head = name === "Object" ? "" : name + " ";
    return `//js(${head}{${body}})`;
  }

  function inspect(v) {
    const t = typeof v;
    if (v === true) return "True";
    if (v === false) return "False";
    if (v === null) return "//js(null)";
    if (v === undefined) return "Nil";
    if (t === "string") return inspectString(v);
    if (t === "bigint" || t === "number") return v.toString();
    if (Array.isArray(v)) return `#(${v.map(inspect).join(", ")})`;
    if (v instanceof List) return `[${v.toArray().map(inspect).join(", ")}]`;
    if (v instanceof UtfCodepoint) return `//utfcodepoint(${String.fromCodePoint(v.value)})`;
    if (v instanceof BitArray) return `<<${Array.from(v.buffer).join(", ")}>>`;
    if (v instanceof CustomType) return inspectCustomType(v);
    if (v instanceof Dict) return inspectDict(v);
    if (v instanceof Set) return `//js(Set(${[...v].map(inspect).join(", ")}))`;
    if (v instanceof RegExp) return `//js(${v})`;
    if (v instanceof Date) return `//js(Date("${v.toISOString()}"))`;
    if (v instanceof Function) {
      const args = [];
      for (const i of Array(v.length).keys()) args.push(String.fromCharCode(i + 97));
      return `//fn(${args.join(", ")}) { ... }`;
    }
    return inspectObject(v);
  }

  function print_debug(string) {
    if (typeof process === "object" && process.stderr?.write) {
      // If we're in Node.js, use `stderr`
      process.stderr.write(string + "\n");
    } else if (typeof Deno === "object") {
      // If we're in Deno, use `stderr`
      Deno.stderr.writeSync(new TextEncoder().encode(string + "\n"));
    } else {
      // Otherwise, use `console.log` (so that it doesn't look like an error)
      console.log(string);
    }
  }

  print_debug(inspect(v));
  return v;
}
