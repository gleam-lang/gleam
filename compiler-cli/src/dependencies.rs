use std::{
    collections::{HashMap, HashSet},
    time::Instant,
};

use flate2::read::GzDecoder;
use gleam_core::{
    build::Mode,
    config::PackageConfig,
    error::{FileIoAction, FileKind},
    hex::{self, HEXPM_PUBLIC_KEY},
    io::{HttpClient as _, TarUnpacker, WrappedReader, WrappedWriter},
    paths, Error, Result,
};
use hexpm::version::{Range, Version};

use crate::{
    cli,
    fs::{self, FileSystemAccessor},
    http::HttpClient,
};

pub fn download() -> Result<Manifest> {
    let span = tracing::info_span!("dependencies");
    let _enter = span.enter();
    let mode = Mode::Dev;

    let http = HttpClient::boxed();
    let fs = FileSystemAccessor::boxed();
    let downloader = hex::Downloader::new(fs, http, Untar::boxed());

    // Read the project config
    let config = crate::config::root_config()?;
    let project_name = config.name.clone();

    // Start event loop so we can run async functions to call the Hex API
    let runtime = tokio::runtime::Runtime::new().expect("Unable to start Tokio async runtime");

    // Determine what versions we need
    let (manifest_updated, manifest) = get_manifest(runtime.handle().clone(), mode, &config)?;
    let local = LocalPackages::read_from_disc()?;

    // Remove any packages that are no longer required due to gleam.toml changes
    remove_extra_packages(&local, &manifest)?;

    // Download them from Hex to the local cache
    runtime.block_on(download_missing_packages(
        downloader,
        &manifest,
        &local,
        project_name,
    ))?;

    // Record new state of the packages directory
    if manifest_updated {
        tracing::info!("writing_manifest_toml");
        manifest.write_to_disc()?;
    }
    LocalPackages::from_manifest(&manifest).write_to_disc()?;

    Ok(manifest)
}

async fn download_missing_packages(
    downloader: hex::Downloader,
    manifest: &Manifest,
    local: &LocalPackages,
    project_name: String,
) -> Result<(), Error> {
    let missing = local.missing_local_packages(manifest, &project_name);
    if !missing.is_empty() {
        let start = Instant::now();
        cli::print_downloading("packages");
        downloader
            .download_hex_packages(&missing, &project_name)
            .await?;
        cli::print_packages_downloaded(start, missing.len());
    }
    Ok(())
}

fn remove_extra_packages(local: &LocalPackages, manifest: &Manifest) -> Result<()> {
    for (package, version) in local.extra_local_packages(manifest) {
        let path = paths::build_deps_package(&package);
        if path.exists() {
            tracing::info!(package=%package, version=%version, "removing_unneeded_package");
            fs::delete_dir(&path)?;
        }
    }
    Ok(())
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Manifest {
    #[serde(serialize_with = "ordered_map")]
    pub requirements: HashMap<String, Range>,
    #[serde(serialize_with = "sorted_vec")]
    pub packages: Vec<ManifestPackage>,
}

impl Manifest {
    pub fn read_from_disc() -> Result<Self> {
        tracing::info!("Reading manifest.toml");
        let manifest_path = paths::manifest();
        let toml = crate::fs::read(&manifest_path)?;
        let manifest = toml::from_str(&toml).map_err(|e| Error::FileIo {
            action: FileIoAction::Parse,
            kind: FileKind::File,
            path: manifest_path.clone(),
            err: Some(e.to_string()),
        })?;
        Ok(manifest)
    }

    pub fn write_to_disc(&self) -> Result<()> {
        let path = paths::manifest();
        let mut file = fs::writer(&path)?;
        self.write_to(&mut file)?;
        Ok(())
    }

    // Rather than using the toml library to do serialization we implement it
    // manually so that we can control the formatting.
    // We want to keep entries on a single line each so that they are more
    // resistant to merge conflicts and are easier to fix when it does happen.
    pub fn write_to(&self, buffer: &mut WrappedWriter) -> Result<()> {
        let Self {
            requirements,
            packages,
        } = self;
        buffer.write(
            b"# This file was generated by Gleam
# You typically do not need to edit this file

",
        )?;

        // Packages
        buffer.write(b"packages = [\n")?;
        for ManifestPackage { name, version } in packages {
            buffer.write(br#"  { name = ""#)?;
            buffer.write(name.as_bytes())?;
            buffer.write(br#"", version = ""#)?;
            buffer.write(version.to_string().as_bytes())?;
            buffer.write(b"\" }\n")?;
        }
        buffer.write(b"]\n\n")?;

        // Requirements
        buffer.write(b"[requirements]\n")?;
        for (name, requirement) in requirements {
            buffer.write(name.as_bytes())?;
            buffer.write(br#" = ""#)?;
            buffer.write(requirement.as_str().as_bytes())?;
            buffer.write(b"\"\n")?;
        }

        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
pub struct ManifestPackage {
    pub name: String,
    pub version: Version,
}

fn ordered_map<S, K, V>(value: &HashMap<K, V>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
    K: serde::Serialize + Ord,
    V: serde::Serialize,
{
    use serde::Serialize;
    let ordered: std::collections::BTreeMap<_, _> = value.iter().collect();
    ordered.serialize(serializer)
}

fn sorted_vec<S, T>(value: &Vec<T>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
    T: serde::Serialize + Ord,
{
    use serde::Serialize;
    let mut value: Vec<&T> = value.iter().collect();
    value.sort();
    value.serialize(serializer)
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct LocalPackages {
    packages: HashMap<String, Version>,
}

impl LocalPackages {
    pub fn extra_local_packages(&self, manifest: &Manifest) -> Vec<(String, Version)> {
        let manifest_packages: HashSet<_> = manifest
            .packages
            .iter()
            .map(|p| (&p.name, &p.version))
            .collect();
        self.packages
            .iter()
            .filter(|(n, v)| !manifest_packages.contains(&(&n, &v)))
            .map(|(n, v)| (n.clone(), v.clone()))
            .collect()
    }

    pub fn missing_local_packages(
        &self,
        manifest: &Manifest,
        root: &str,
    ) -> Vec<(String, Version)> {
        manifest
            .packages
            .iter()
            .filter(|p| p.name != root && self.packages.get(&p.name) != Some(&p.version))
            .map(|p| (p.name.clone(), p.version.clone()))
            .collect()
    }

    pub fn read_from_disc() -> Result<Self> {
        let path = paths::packages_toml();
        if !path.exists() {
            return Ok(Self {
                packages: HashMap::new(),
            });
        }
        let toml = crate::fs::read(&path)?;
        toml::from_str(&toml).map_err(|e| Error::FileIo {
            action: FileIoAction::Parse,
            kind: FileKind::File,
            path: path.clone(),
            err: Some(e.to_string()),
        })
    }

    pub fn write_to_disc(&self) -> Result<()> {
        let path = paths::packages_toml();
        let toml = toml::to_string(&self).expect("packages.toml serialization");
        fs::write(&path, &toml)
    }

    pub fn from_manifest(manifest: &Manifest) -> Self {
        Self {
            packages: manifest
                .packages
                .iter()
                .map(|p| (p.name.clone(), p.version.clone()))
                .collect(),
        }
    }
}

#[test]
fn missing_local_packages() {
    let mut extra = LocalPackages {
        packages: [
            ("local2".to_string(), Version::parse("2.0.0").unwrap()),
            ("local3".to_string(), Version::parse("3.0.0").unwrap()),
        ]
        .into(),
    }
    .missing_local_packages(
        &Manifest {
            requirements: HashMap::new(),
            packages: vec![
                ManifestPackage {
                    name: "root".to_string(),
                    version: Version::parse("1.0.0").unwrap(),
                },
                ManifestPackage {
                    name: "local1".to_string(),
                    version: Version::parse("1.0.0").unwrap(),
                },
                ManifestPackage {
                    name: "local2".to_string(),
                    version: Version::parse("3.0.0").unwrap(),
                },
            ],
        },
        "root",
    );
    extra.sort();
    assert_eq!(
        extra,
        [
            ("local1".to_string(), Version::new(1, 0, 0)),
            ("local2".to_string(), Version::new(3, 0, 0)),
        ]
    )
}

#[test]
fn extra_local_packages() {
    let mut extra = LocalPackages {
        packages: [
            ("local1".to_string(), Version::parse("1.0.0").unwrap()),
            ("local2".to_string(), Version::parse("2.0.0").unwrap()),
            ("local3".to_string(), Version::parse("3.0.0").unwrap()),
        ]
        .into(),
    }
    .extra_local_packages(&Manifest {
        requirements: HashMap::new(),
        packages: vec![
            ManifestPackage {
                name: "local1".to_string(),
                version: Version::parse("1.0.0").unwrap(),
            },
            ManifestPackage {
                name: "local2".to_string(),
                version: Version::parse("3.0.0").unwrap(),
            },
        ],
    });
    extra.sort();
    assert_eq!(
        extra,
        [
            ("local2".to_string(), Version::new(2, 0, 0)),
            ("local3".to_string(), Version::new(3, 0, 0)),
        ]
    )
}

fn get_manifest(
    runtime: tokio::runtime::Handle,
    mode: Mode,
    config: &PackageConfig,
) -> Result<(bool, Manifest)> {
    // If there's no manifest then resolve the versions anew
    if !paths::manifest().exists() {
        tracing::info!("manifest_not_present");
        let manifest = resolve_versions(runtime, mode, config, &[])?;
        return Ok((true, manifest));
    }

    let manifest = Manifest::read_from_disc()?;

    // If the config has unchanged since the manifest was written then it is up
    // to date so we can return it unmodified.
    if manifest.requirements == config.all_dependencies()? {
        tracing::info!("manifest_up_to_date");
        Ok((false, manifest))
    } else {
        tracing::info!("manifest_outdated");
        let manifest = resolve_versions(runtime, mode, config, &manifest.packages)?;
        Ok((true, manifest))
    }
}

fn resolve_versions(
    runtime: tokio::runtime::Handle,
    mode: Mode,
    config: &PackageConfig,
    locked: &[ManifestPackage],
) -> Result<Manifest, Error> {
    cli::print_resolving_versions();
    let locked = locked
        .iter()
        // TODO: remove clones. Will require library modification.
        .map(|p| (p.name.clone(), p.version.clone()))
        .collect();
    let resolved = hex::resolve_versions(PackageFetcher::boxed(runtime), mode, config, &locked)?;
    let packages = resolved
        .into_iter()
        .map(|(name, version)| ManifestPackage { name, version })
        .collect();
    let manifest = Manifest {
        packages,
        requirements: config.all_dependencies()?,
    };
    Ok(manifest)
}

struct PackageFetcher {
    runtime: tokio::runtime::Handle,
    http: HttpClient,
}

impl PackageFetcher {
    pub fn boxed(runtime: tokio::runtime::Handle) -> Box<Self> {
        Box::new(Self {
            runtime,
            http: HttpClient::new(),
        })
    }
}

#[derive(Debug)]
pub struct Untar;

impl Untar {
    pub fn boxed() -> Box<Self> {
        Box::new(Self)
    }
}

impl TarUnpacker for Untar {
    fn io_result_entries<'a>(
        &self,
        archive: &'a mut tar::Archive<WrappedReader>,
    ) -> std::io::Result<tar::Entries<'a, WrappedReader>> {
        archive.entries()
    }

    fn io_result_unpack(
        &self,
        path: &std::path::Path,
        mut archive: tar::Archive<GzDecoder<tar::Entry<'_, WrappedReader>>>,
    ) -> std::io::Result<()> {
        archive.unpack(path)
    }
}

impl hexpm::version::PackageFetcher for PackageFetcher {
    fn get_dependencies(
        &self,
        package: &str,
    ) -> Result<hexpm::Package, Box<dyn std::error::Error>> {
        tracing::info!(package = package, "Looking up package in Hex API");
        let config = hexpm::Config::new();
        let request = hexpm::get_package_request(package, None, &config);
        let response = self
            .runtime
            .block_on(self.http.send(request))
            .map_err(Box::new)?;
        hexpm::get_package_response(response, HEXPM_PUBLIC_KEY).map_err(|e| e.into())
    }
}
